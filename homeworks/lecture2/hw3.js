// 浮点数精度问题：0.1 + 0.2 实际结果是 0.30000000000000004
console.log(0.1 + 0.2);
// 输出：0.30000000000000004

// 因为上面不是严格等于 0.3，所以返回 false
console.log(0.1 + 0.2 === 0.3);
// 输出：false

// "1" + "2" + "2"，第一个是数字 + 字符串，发生隐式类型转换变成字符串拼接
console.log(1 +  "2" + "2");
// 输出："122"

// +"2" 是一元加号，表示将字符串 "2" 转换成数字 2
// 所以是 1 + 2 + "2" => 3 + "2" => "32"
console.log(1 +  +"2" + "2");
// 输出："32"

// -"1" 把字符串 "1" 转成数字并取反 => -1
// 1 + (-1) + "2" => 0 + "2" => "02"
console.log(1 +  -"1" + "2");
// 输出："02"

// +"1" => 数字 1，1 + "1" => "11"，再 + "2" => "112"
console.log(+"1" +  "1" + "2");
// 输出："112"

// "A" 和 "B" 都是字符串，尝试做减法时会被转换为 NaN（不是数字）
// NaN + "2" => "NaN2"（字符串拼接）
console.log("A" - "B" + "2");
// 输出："NaN2"

// "A" - "B" => NaN，再 + 2 => NaN
console.log("A" - "B" + 2);
// 输出：NaN

// 逻辑或（||）：0 是假值，1 是真值，所以 0 || 1 => 1
console.log("0 || 1 = " + (0 || 1));
// 输出："0 || 1 = 1"

// 1 是真值，逻辑或短路，直接返回 1
console.log("1 || 2 = " + (1 || 2));
// 输出："1 || 2 = 1"

// 逻辑与（&&）：0 是假值，所以 0 && 1 => 0（短路）
console.log("0 && 1 = " + (0 && 1));
// 输出："0 && 1 = 0"

// 1 是真值，继续判断 2，也是真值 => 返回最后一个 2
console.log("1 && 2 = " + (1 && 2));
// 输出："1 && 2 = 2"

// '0' 是字符串，但非空 => 被转为 true，false == true 是 false，但 false == "0" 是 true（类型转换）
console.log(false == '0');
// 输出：true

// === 是严格等于，不做类型转换，布尔值和字符串类型不同 => false
console.log(false === '0');
// 输出：false
